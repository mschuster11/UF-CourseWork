
Lab6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000428  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  0000049c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  00802000  00802000  0000049c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000049c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004cc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000b8  00000000  00000000  0000050c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000498a  00000000  00000000  000005c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003e8b  00000000  00000000  00004f4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000979  00000000  00000000  00008dd9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000164  00000000  00000000  00009754  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000031f0  00000000  00000000  000098b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000039d  00000000  00000000  0000caa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  0000ce45  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
   8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__vector_2>
   c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  10:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  14:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  18:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  1c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  20:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  24:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  28:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  2c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  30:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  34:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  38:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  3c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  40:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  44:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  48:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  4c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  50:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  54:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  58:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  5c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  60:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  64:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  68:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  6c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  70:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  74:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  78:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  7c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  80:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  84:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  88:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  8c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  90:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  94:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  98:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  9c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  fc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 100:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 104:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 108:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 10c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 110:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 114:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 118:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 11c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 120:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 124:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 128:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 12c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 130:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 134:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 138:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 13c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 140:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 144:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 148:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 14c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 150:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 154:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 158:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 15c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 160:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 164:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 168:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 16c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 170:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 174:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 178:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 17c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 180:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 184:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 188:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 18c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 190:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 194:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 198:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 19c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e3       	ldi	r29, 0x3F	; 63
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60
 20c:	18 be       	out	0x38, r1	; 56
 20e:	19 be       	out	0x39, r1	; 57
 210:	1a be       	out	0x3a, r1	; 58
 212:	1b be       	out	0x3b, r1	; 59

00000214 <__do_clear_bss>:
 214:	20 e2       	ldi	r18, 0x20	; 32
 216:	a0 e0       	ldi	r26, 0x00	; 0
 218:	b0 e2       	ldi	r27, 0x20	; 32
 21a:	01 c0       	rjmp	.+2      	; 0x21e <.do_clear_bss_start>

0000021c <.do_clear_bss_loop>:
 21c:	1d 92       	st	X+, r1

0000021e <.do_clear_bss_start>:
 21e:	a1 30       	cpi	r26, 0x01	; 1
 220:	b2 07       	cpc	r27, r18
 222:	e1 f7       	brne	.-8      	; 0x21c <.do_clear_bss_loop>
 224:	0e 94 57 01 	call	0x2ae	; 0x2ae <main>
 228:	0c 94 12 02 	jmp	0x424	; 0x424 <_exit>

0000022c <__bad_interrupt>:
 22c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000230 <INIT_CLK>:
// Inputs: None
// Outputs: None
// Affected: None
void INIT_CLK(void){
	// Enable 32Mhz CLK.
	OSC_CTRL = OSC_RC32MEN_bm;
 230:	82 e0       	ldi	r24, 0x02	; 2
 232:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>

	// Wait for 32Mhz flag to be set.
	while( !(OSC_STATUS & OSC_RC32MRDY_bm) );
 236:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
 23a:	81 ff       	sbrs	r24, 1
 23c:	fc cf       	rjmp	.-8      	; 0x236 <INIT_CLK+0x6>

	// Write to restriction register to allow writing
	// to the CLK CTRL, then sel the 32MHz CLK.
	CPU_CCP = CCP_IOREG_gc;
 23e:	88 ed       	ldi	r24, 0xD8	; 216
 240:	84 bf       	out	0x34, r24	; 52
	CLK_CTRL = CLK_SCLKSEL_RC32M_gc;
 242:	91 e0       	ldi	r25, 0x01	; 1
 244:	90 93 40 00 	sts	0x0040, r25	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>

	// Write to restriction register to allow writing
	// to the CLK PSCTRL, then set the prescaler.
	CPU_CCP = CCP_IOREG_gc;
 248:	84 bf       	out	0x34, r24	; 52
	CLK_PSCTRL = CLK_PRESCALER;
 24a:	10 92 41 00 	sts	0x0041, r1	; 0x800041 <__TEXT_REGION_LENGTH__+0x700041>
 24e:	08 95       	ret

00000250 <INIT_RGB>:
// Init the RGB LED.
// Inputs: None
// Outputs: None
// Affected: None
void INIT_RGB(void){
	PORTD_DIRSET 	= 0b01110000;
 250:	80 e7       	ldi	r24, 0x70	; 112
 252:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTD_REMAP  	= 0b00000111;
 256:	87 e0       	ldi	r24, 0x07	; 7
 258:	80 93 6e 06 	sts	0x066E, r24	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
	
	// Value to set the prescaler of the TC to be 1 times the sys CLK.
	TCD0_CTRLA   	= 0b00000001;
 25c:	81 e0       	ldi	r24, 0x01	; 1
 25e:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
	
	// Sets the PWM mode of the TC to single slope.
	TCD0_CTRLB 		= 0b01110011;
 262:	83 e7       	ldi	r24, 0x73	; 115
 264:	80 93 01 09 	sts	0x0901, r24	; 0x800901 <__TEXT_REGION_LENGTH__+0x700901>
	TCD0_PER		= 0xFFFF;
 268:	8f ef       	ldi	r24, 0xFF	; 255
 26a:	9f ef       	ldi	r25, 0xFF	; 255
 26c:	80 93 26 09 	sts	0x0926, r24	; 0x800926 <__TEXT_REGION_LENGTH__+0x700926>
 270:	90 93 27 09 	sts	0x0927, r25	; 0x800927 <__TEXT_REGION_LENGTH__+0x700927>
	PORTD_OUTSET	= 0x00;
 274:	10 92 65 06 	sts	0x0665, r1	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 278:	08 95       	ret

0000027a <setRGB>:
// Sets the value of the RGB LED. 
// Inputs: None
// Outputs: None
// Affected: None
void setRGB(uint16_t redVal, uint16_t greenVal, uint16_t blueVal){
	TCD0_CCA = ~redVal;
 27a:	80 95       	com	r24
 27c:	90 95       	com	r25
 27e:	80 93 28 09 	sts	0x0928, r24	; 0x800928 <__TEXT_REGION_LENGTH__+0x700928>
 282:	90 93 29 09 	sts	0x0929, r25	; 0x800929 <__TEXT_REGION_LENGTH__+0x700929>
	TCD0_CCB = ~greenVal;
 286:	60 95       	com	r22
 288:	70 95       	com	r23
 28a:	60 93 2a 09 	sts	0x092A, r22	; 0x80092a <__TEXT_REGION_LENGTH__+0x70092a>
 28e:	70 93 2b 09 	sts	0x092B, r23	; 0x80092b <__TEXT_REGION_LENGTH__+0x70092b>
	TCD0_CCC = ~blueVal;
 292:	40 95       	com	r20
 294:	50 95       	com	r21
 296:	40 93 2c 09 	sts	0x092C, r20	; 0x80092c <__TEXT_REGION_LENGTH__+0x70092c>
 29a:	50 93 2d 09 	sts	0x092D, r21	; 0x80092d <__TEXT_REGION_LENGTH__+0x70092d>
 29e:	08 95       	ret

000002a0 <INIT_INTS>:
// Inputs: None
// Outputs: None
// Affected: None
void INIT_INTS(void){
	// Set the PMIC to enable low level interrupts.
	PMIC_CTRL = PMIC_LOLVLEN_bm;
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Set the interrupt enable bit.
	CPU_SREG |= 0x80;
 2a6:	8f b7       	in	r24, 0x3f	; 63
 2a8:	80 68       	ori	r24, 0x80	; 128
 2aa:	8f bf       	out	0x3f, r24	; 63
 2ac:	08 95       	ret

000002ae <main>:
volatile bool accelDataReady = FALSE;



int main(void)
{
 2ae:	cf 93       	push	r28
 2b0:	df 93       	push	r29
 2b2:	00 d0       	rcall	.+0      	; 0x2b4 <main+0x6>
 2b4:	00 d0       	rcall	.+0      	; 0x2b6 <main+0x8>
 2b6:	cd b7       	in	r28, 0x3d	; 61
 2b8:	de b7       	in	r29, 0x3e	; 62
	// Init CLK, pin dir, and ADC.
	volatile uint16_t accelXData;
	volatile uint16_t accelYData;
	volatile uint16_t accelZData;

	INIT_CLK();
 2ba:	0e 94 18 01 	call	0x230	; 0x230 <INIT_CLK>
	INIT_RGB();
 2be:	0e 94 28 01 	call	0x250	; 0x250 <INIT_RGB>
	INIT_INTS();
 2c2:	0e 94 50 01 	call	0x2a0	; 0x2a0 <INIT_INTS>
	accel_init();
 2c6:	0e 94 db 01 	call	0x3b6	; 0x3b6 <accel_init>
	
	while (1){
		if(accelDataReady){
 2ca:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
 2ce:	88 23       	and	r24, r24
 2d0:	e1 f3       	breq	.-8      	; 0x2ca <main+0x1c>
			uint8_t accelXLData = accelRead(OUT_X_L_A);
 2d2:	88 e2       	ldi	r24, 0x28	; 40
 2d4:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
 2d8:	18 2f       	mov	r17, r24
			uint8_t accelXHData = accelRead(OUT_X_H_A);
 2da:	89 e2       	ldi	r24, 0x29	; 41
 2dc:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
			accelXData = (accelXHData << 8) | accelXLData;
 2e0:	21 2f       	mov	r18, r17
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	38 2b       	or	r19, r24
 2e6:	2d 83       	std	Y+5, r18	; 0x05
 2e8:	3e 83       	std	Y+6, r19	; 0x06
			uint8_t accelYLData = accelRead(OUT_Y_L_A);
 2ea:	8a e2       	ldi	r24, 0x2A	; 42
 2ec:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
 2f0:	18 2f       	mov	r17, r24
			uint8_t accelYHData = accelRead(OUT_Y_H_A);
 2f2:	8b e2       	ldi	r24, 0x2B	; 43
 2f4:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
			accelYData = (accelYHData << 8) | accelYLData;
 2f8:	21 2f       	mov	r18, r17
 2fa:	30 e0       	ldi	r19, 0x00	; 0
 2fc:	38 2b       	or	r19, r24
 2fe:	2b 83       	std	Y+3, r18	; 0x03
 300:	3c 83       	std	Y+4, r19	; 0x04
			uint8_t accelZLData = accelRead(OUT_Z_L_A);
 302:	8c e2       	ldi	r24, 0x2C	; 44
 304:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
 308:	18 2f       	mov	r17, r24
			uint8_t accelZHData = accelRead(OUT_Z_H_A);
 30a:	8d e2       	ldi	r24, 0x2D	; 45
 30c:	0e 94 be 01 	call	0x37c	; 0x37c <accelRead>
			accelZData = (accelZHData << 8) | accelZLData;
 310:	21 2f       	mov	r18, r17
 312:	30 e0       	ldi	r19, 0x00	; 0
 314:	38 2b       	or	r19, r24
 316:	29 83       	std	Y+1, r18	; 0x01
 318:	3a 83       	std	Y+2, r19	; 0x02
			accelXData =  (accelXData < 0) ? (0-accelXData) : accelXData;
 31a:	8d 81       	ldd	r24, Y+5	; 0x05
 31c:	9e 81       	ldd	r25, Y+6	; 0x06
 31e:	8d 81       	ldd	r24, Y+5	; 0x05
 320:	9e 81       	ldd	r25, Y+6	; 0x06
 322:	8d 83       	std	Y+5, r24	; 0x05
 324:	9e 83       	std	Y+6, r25	; 0x06
			accelYData =  (accelYData < 0) ? (0-accelYData) : accelYData;
 326:	8b 81       	ldd	r24, Y+3	; 0x03
 328:	9c 81       	ldd	r25, Y+4	; 0x04
 32a:	8b 81       	ldd	r24, Y+3	; 0x03
 32c:	9c 81       	ldd	r25, Y+4	; 0x04
 32e:	8b 83       	std	Y+3, r24	; 0x03
 330:	9c 83       	std	Y+4, r25	; 0x04
			accelZData =  (accelZData < 0) ? (0-accelZData) : accelZData;
 332:	89 81       	ldd	r24, Y+1	; 0x01
 334:	9a 81       	ldd	r25, Y+2	; 0x02
 336:	89 81       	ldd	r24, Y+1	; 0x01
 338:	9a 81       	ldd	r25, Y+2	; 0x02
 33a:	89 83       	std	Y+1, r24	; 0x01
 33c:	9a 83       	std	Y+2, r25	; 0x02

			setRGB(accelXData, accelYData, accelZData);
 33e:	49 81       	ldd	r20, Y+1	; 0x01
 340:	5a 81       	ldd	r21, Y+2	; 0x02
 342:	6b 81       	ldd	r22, Y+3	; 0x03
 344:	7c 81       	ldd	r23, Y+4	; 0x04
 346:	8d 81       	ldd	r24, Y+5	; 0x05
 348:	9e 81       	ldd	r25, Y+6	; 0x06
 34a:	0e 94 3d 01 	call	0x27a	; 0x27a <setRGB>
			accelDataReady = FALSE;
 34e:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <_edata>
 352:	bb cf       	rjmp	.-138    	; 0x2ca <main+0x1c>

00000354 <__vector_2>:
// Sets up an interrupt to be triggered by rising edge on port C's pin 7.
//
// Inputs: None
// Outputs: None
// Affected: None
ISR(PORTC_INT0_vect){
 354:	1f 92       	push	r1
 356:	0f 92       	push	r0
 358:	0f b6       	in	r0, 0x3f	; 63
 35a:	0f 92       	push	r0
 35c:	11 24       	eor	r1, r1
 35e:	08 b6       	in	r0, 0x38	; 56
 360:	0f 92       	push	r0
 362:	18 be       	out	0x38, r1	; 56
 364:	8f 93       	push	r24
	accelDataReady = TRUE;
 366:	81 e0       	ldi	r24, 0x01	; 1
 368:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <_edata>
	return;
}
 36c:	8f 91       	pop	r24
 36e:	0f 90       	pop	r0
 370:	08 be       	out	0x38, r0	; 56
 372:	0f 90       	pop	r0
 374:	0f be       	out	0x3f, r0	; 63
 376:	0f 90       	pop	r0
 378:	1f 90       	pop	r1
 37a:	18 95       	reti

0000037c <accelRead>:
// Subroutine Name: accelRead
// Read a byte from the accelerometer.
// Inputs: None
// Outputs: Byte read from accelerometer.
// Affected: None
uint8_t accelRead(uint8_t targetReg){
 37c:	cf 93       	push	r28
	uint8_t spiVal = 0x80 | targetReg;
	uint8_t result;
	PORTF_OUTCLR = RBB_SSA;
 37e:	c8 e0       	ldi	r28, 0x08	; 8
 380:	c0 93 a6 06 	sts	0x06A6, r28	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	spiWrite(spiVal);
 384:	80 68       	ori	r24, 0x80	; 128
 386:	0e 94 06 02 	call	0x40c	; 0x40c <spiWrite>
	result = spiRead();
 38a:	0e 94 0f 02 	call	0x41e	; 0x41e <spiRead>
	PORTF_OUTSET = RBB_SSA;
 38e:	c0 93 a5 06 	sts	0x06A5, r28	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
	return result;
}
 392:	cf 91       	pop	r28
 394:	08 95       	ret

00000396 <accelWrite>:
// Subroutine Name: accelWrite
// Write a byte to the accelerometer.
// Inputs: Byte to be written.
// Outputs: None
// Affected: None
void accelWrite(uint8_t targetReg, uint8_t data){
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	d6 2f       	mov	r29, r22
	uint8_t spiVal = 0x00 | targetReg;
	PORTF_OUTCLR = RBB_SSA;
 39c:	c8 e0       	ldi	r28, 0x08	; 8
 39e:	c0 93 a6 06 	sts	0x06A6, r28	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	spiWrite(spiVal);
 3a2:	0e 94 06 02 	call	0x40c	; 0x40c <spiWrite>
	spiWrite(data);
 3a6:	8d 2f       	mov	r24, r29
 3a8:	0e 94 06 02 	call	0x40c	; 0x40c <spiWrite>
	PORTF_OUTSET = RBB_SSA;
 3ac:	c0 93 a5 06 	sts	0x06A5, r28	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
 3b4:	08 95       	ret

000003b6 <accel_init>:
// Init the accelerometer.
// Inputs: None
// Outputs: None
// Affected: None
void accel_init(void){
	PORTA_DIRSET = RBB_PROTOCOL_SEL;
 3b6:	80 e1       	ldi	r24, 0x10	; 16
 3b8:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	PORTA_OUTCLR = RBB_PROTOCOL_SEL;
 3bc:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	PORTF_OUTSET = RBB_SSA | RBB_SSG | RBB_SENSOR_SEL_ACCEl_bp;
 3c0:	8c e1       	ldi	r24, 0x1C	; 28
 3c2:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
	spi_init();
 3c6:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <spi_init>
	accelWrite(CTRL_REG4_A, CTRL_REG4_A_STRT);
 3ca:	61 e0       	ldi	r22, 0x01	; 1
 3cc:	83 e2       	ldi	r24, 0x23	; 35
 3ce:	0e 94 cb 01 	call	0x396	; 0x396 <accelWrite>
	PORTC_DIRCLR = RBB_INT1A;
 3d2:	80 e8       	ldi	r24, 0x80	; 128
 3d4:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
	PORTC_PIN7CTRL = PORT_ISC_FALLING_gc;
 3d8:	92 e0       	ldi	r25, 0x02	; 2
 3da:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <__TEXT_REGION_LENGTH__+0x700657>
	PORTC_INT0MASK = RBB_INT1A;
 3de:	80 93 4a 06 	sts	0x064A, r24	; 0x80064a <__TEXT_REGION_LENGTH__+0x70064a>
	PORTC_INTCTRL = PORT_INT0LVL_LO_gc;
 3e2:	81 e0       	ldi	r24, 0x01	; 1
 3e4:	80 93 49 06 	sts	0x0649, r24	; 0x800649 <__TEXT_REGION_LENGTH__+0x700649>
	uint8_t reg4AInitData = CTRL_REG4_A_DR_EN | CTRL_REG4_A_IEA | CTRL_REG4_A_INT1_EN;
	accelWrite(CTRL_REG4_A, reg4AInitData);
 3e8:	68 ec       	ldi	r22, 0xC8	; 200
 3ea:	83 e2       	ldi	r24, 0x23	; 35
 3ec:	0e 94 cb 01 	call	0x396	; 0x396 <accelWrite>
	uint8_t reg5AInitData = CTRL_REG5_A_ODR3 | CTRL_REG5_A_ODR0 | CTRL_REG5_A_ZEN | CTRL_REG5_A_YEN | CTRL_REG5_A_XEN;
	accelWrite(CTRL_REG5_A, reg5AInitData);
 3f0:	67 e9       	ldi	r22, 0x97	; 151
 3f2:	80 e2       	ldi	r24, 0x20	; 32
 3f4:	0c 94 cb 01 	jmp	0x396	; 0x396 <accelWrite>

000003f8 <spi_init>:
 // Inputs: None
 // Outputs: None
 // Affected: None
 void spi_init(void){

	 PORTF_DIRSET = 0b10111100;
 3f8:	8c eb       	ldi	r24, 0xBC	; 188
 3fa:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
	 PORTF_DIRCLR = 0b01000011;
 3fe:	83 e4       	ldi	r24, 0x43	; 67
 400:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <__TEXT_REGION_LENGTH__+0x7006a2>
	 // Master, MSB DORD, LE:RS, TE:FS, SYS_CLK/4 = 8MHz
	 SPIF_CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV4_gc;
 404:	80 e5       	ldi	r24, 0x50	; 80
 406:	80 93 c0 0b 	sts	0x0BC0, r24	; 0x800bc0 <__TEXT_REGION_LENGTH__+0x700bc0>
 40a:	08 95       	ret

0000040c <spiWrite>:
 // Write a byte of data using SPI
 // Inputs: data - data to be sent
 // Outputs: None
 // Affected: None
 uint8_t spiWrite(uint8_t data){
	 SPIF_DATA = data;
 40c:	80 93 c3 0b 	sts	0x0BC3, r24	; 0x800bc3 <__TEXT_REGION_LENGTH__+0x700bc3>
	 while(!(SPIF_STATUS & SPI_IF_bm));
 410:	80 91 c2 0b 	lds	r24, 0x0BC2	; 0x800bc2 <__TEXT_REGION_LENGTH__+0x700bc2>
 414:	87 ff       	sbrs	r24, 7
 416:	fc cf       	rjmp	.-8      	; 0x410 <spiWrite+0x4>
	 return SPIF_DATA;
 418:	80 91 c3 0b 	lds	r24, 0x0BC3	; 0x800bc3 <__TEXT_REGION_LENGTH__+0x700bc3>
 }
 41c:	08 95       	ret

0000041e <spiRead>:
 // Reads the return value of spiWrite.
 // Inputs: None
 // Outputs: Return value of spiWrite.
 // Affected: None
 uint8_t spiRead(void){
	 return  spiWrite(0xFF);
 41e:	8f ef       	ldi	r24, 0xFF	; 255
 420:	0c 94 06 02 	jmp	0x40c	; 0x40c <spiWrite>

00000424 <_exit>:
 424:	f8 94       	cli

00000426 <__stop_program>:
 426:	ff cf       	rjmp	.-2      	; 0x426 <__stop_program>
